
Перем ЕстьИзменения;

// Выравнивает код по установленным фрагментам
//
// Параметры:
//  ИсходныйКод  - ТабличныйДокумент - Код для выравнивания
//
// Возвращаемое значение:
//   Булево   - Есть изменения
//
Функция ВыровнитьКод( ИсходныйКод ) Экспорт
	
	ЕстьИзменения = Ложь;

	Для каждого цФрагмент Из ФрагментыВыравнивания() Цикл
		
		ВыровнитьКодПоФрагменту( ИсходныйКод, цФрагмент );
		
	КонецЦикла;
	
	Возврат ЕстьИзменения;

КонецФункции

Функция ФрагментыВыравнивания()

	фрагментыВыравнивания = Новый СписокЗначений;        // Используется список, чтобы сохранить порядок
	фрагментыВыравнивания.Добавить( "="    , "Право" );  // Право означает, что фрагмент будет находится справа от добавленных пробелов
	фрагментыВыравнивания.Добавить( ","    , "Лево" );   // см. пример в функции РазделителиСлов
	фрагментыВыравнивания.Добавить( "//"   , "Право" );  // Выравнивание комментариев, как в тут
	фрагментыВыравнивания.Добавить( " КАК ", "Право" );
	
	Возврат фрагментыВыравнивания;

КонецФункции

Функция СдвигПревышение()

	Возврат 15;

КонецФункции

Функция РазделителиСлов()
	
	РазделителиСлов = Новый Соответствие;
	РазделителиСлов.Вставить( "ЕСЛИ", 				Истина );
	РазделителиСлов.Вставить( "#ЕСЛИ", 				Истина );
	РазделителиСлов.Вставить( "ИНАЧЕЕСЛИ", 			Истина );
	РазделителиСлов.Вставить( "КОНЕЦЕСЛИ", 			Истина );
	РазделителиСлов.Вставить( "#КОНЕЦЕСЛИ", 		Истина );
	РазделителиСлов.Вставить( "ТОГДА", 				Истина );
	РазделителиСлов.Вставить( "И",                  Истина );
	РазделителиСлов.Вставить( "ИЛИ", 				Истина );
	РазделителиСлов.Вставить( "НЕ", 				Истина );
	РазделителиСлов.Вставить( "ИЗ", 				Истина );
	РазделителиСлов.Вставить( "КАЖДОГО", 			Истина );
	РазделителиСлов.Вставить( "ДЛЯ", 				Истина );
	РазделителиСлов.Вставить( "ЦИКЛ", 				Истина );
	РазделителиСлов.Вставить( "ПОКА", 				Истина );
	РазделителиСлов.Вставить( "ПРОЦЕДУРА", 			Истина );
	РазделителиСлов.Вставить( "ФУНКЦИЯ", 			Истина );
	РазделителиСлов.Вставить( "КОНЕЦПРОЦЕДУРЫ", 	Истина );
	РазделителиСлов.Вставить( "КОНЕЦФУНКЦИИ", 		Истина );
	РазделителиСлов.Вставить( "ЭКСПОРТ", 			Истина );
	РазделителиСлов.Вставить( "ПЕРЕМ", 				Истина );
	РазделителиСлов.Вставить( "ЗНАЧ", 				Истина );
	РазделителиСлов.Вставить( "ПЕРЕЙТИ", 			Истина );
	РазделителиСлов.Вставить( "ВЫЗВАТЬИСКЛЮЧЕНИЕ", 	Истина );
	РазделителиСлов.Вставить( "ПОПЫТКА", 			Истина );
	РазделителиСлов.Вставить( "ИСКЛЮЧЕНИЕ", 		Истина );
	РазделителиСлов.Вставить( "КОНЕЦПОПЫТКИ", 		Истина );
	РазделителиСлов.Вставить( "ВОЗВРАТ", 			Истина );
	
	Возврат РазделителиСлов;
	
КонецФункции

Процедура ВыровнитьКодПоФрагменту( ТекстовыйДокумент, Знач пФрагмент )
	
	разделителиСлов = РазделителиСлов();
	
	фрагмент = пФрагмент.Значение;
	выравнивание = пФрагмент.Представление;
	
	массивСтрок = Новый Массив;
	
	Для цНомерСтроки = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		
		цТекСтрока = ТекстовыйДокумент.ПолучитьСтроку( цНомерСтроки );
		
		индексФрагмента = Найти( цТекСтрока, фрагмент );
		
		Если индексФрагмента > 0
			И ПодходитДляВыравнивания( цТекСтрока, индексФрагмента ) Тогда
			
			массивСтрок.Добавить( цНомерСтроки );
			
			СвернутьПробелы( цТекСтрока, фрагмент, выравнивание );
			ТекстовыйДокумент.ЗаменитьСтроку( цНомерСтроки, цТекСтрока );
			
		Иначе
			
			РазвернутьПробелы( ТекстовыйДокумент, массивСтрок, фрагмент, выравнивание );
			
		КонецЕсли;
		
	КонецЦикла;
	
	РазвернутьПробелы( ТекстовыйДокумент, массивСтрок, фрагмент, выравнивание );

КонецПроцедуры

Функция ПодходитДляВыравнивания( Знач пСтрока, пИндексФрагмента )
	
	Если Найти( СокрЛ(пСтрока), "//" ) = 1 Тогда
		// Если строка полностью состоит из комментария, то не трогаем ее
		Возврат Ложь;
	КонецЕсли;
	
	индексКомментария = Найти( пСтрока, "//" );
	
	Если пИндексФрагмента > индексКомментария
		И Не индексКомментария = 0 Тогда
		// Нужный фрагмент закомментирован. Так же стоит учитывать, что выравнивание может происходить как раз комментариев,
		// поэтому сравнение строгое.
		Возврат Ложь;
	КонецЕсли;
	
	массивСлов = РазложитьСтрокуВМассивСлов( СокрЛП( пСтрока ) );
	
	Если массивСлов.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не РазделителиСлов()[ ВРег( массивСлов[0] ) ] = Неопределено Тогда
		// Первое слово не является словом, разбивающем блок
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции


Процедура СвернутьПробелы( пСтрока, Знач пФрагмент, Знач пВыравнивание)
	
	ЕстьИзменения = Истина;

	индексФрагмента = Найти( пСтрока, пФрагмент );
	
	Если пВыравнивание = "Право" Тогда
		
		пСтрока = СокрП( Лев( пСтрока, индексФрагмента - 1 ) ) + " " + Сред( пСтрока, индексФрагмента );
		
	ИначеЕсли пВыравнивание = "Лево" Тогда
		
		размерФрагмента = СтрДлина( пФрагмент );
		пСтрока = Лев( пСтрока, индексФрагмента + размерФрагмента - 1 ) + " " + СокрЛ( Сред( пСтрока, индексФрагмента + размерФрагмента ) );
		
	КонецЕсли;

КонецПроцедуры

Процедура РазвернутьПробелы( пТекстДок, пМассивСтрок, Знач пФрагмент, Знач пВыравнивание )
	
	Если пМассивСтрок.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ЕстьИзменения = Истина;

	максПозиция = 0;
	Для каждого цНомерСтроки Из пМассивСтрок Цикл
		
		текСтрока = пТекстДок.ПолучитьСтроку( цНомерСтроки );
		
		максПозиция = Макс( Найти( текСтрока, пФрагмент ), максПозиция );
		
	КонецЦикла;
	
	размерФрагмента = СтрДлина( пФрагмент );
	
	массивКороткихСтрок = Новый Массив();
	сдвигПревышение = СдвигПревышение();
	
	Для каждого цНомерСтроки Из пМассивСтрок Цикл
		
		текСтрока = пТекстДок.ПолучитьСтроку( цНомерСтроки );
		
		индексФрагмента = Найти( текСтрока, пФрагмент );
		
		Если максПозиция - индексФрагмента > сдвигПревышение Тогда
			
			массивКороткихСтрок.Добавить( цНомерСтроки );
			Продолжить;
			
		КонецЕсли;
		
		СтрокаПробелов = "";
		
		Для СчПробелов = 1 По максПозиция - индексФрагмента Цикл
			СтрокаПробелов = СтрокаПробелов + " ";
		КонецЦикла;
		
		Если пВыравнивание = "Право" Тогда
			
			НоваяСтрока = Лев( текСтрока, индексФрагмента - 1 ) + СтрокаПробелов + Сред( текСтрока, индексФрагмента );
			
		ИначеЕсли пВыравнивание = "Лево" Тогда
			
			НоваяСтрока = Лев( текСтрока, индексФрагмента + размерФрагмента - 1 ) + СтрокаПробелов + Сред( текСтрока, индексФрагмента + размерФрагмента );
			
		КонецЕсли;
		
		пТекстДок.ЗаменитьСтроку( цНомерСтроки, СокрП( НоваяСтрока ) );
		
	КонецЦикла;
	
	РазвернутьПробелы( пТекстДок, массивКороткихСтрок, пФрагмент, пВыравнивание );
	
	пМассивСтрок = Новый Массив;
	
КонецПроцедуры



// Разбивает строку на несколько строк, используя заданный набор разделителей.
// Если параметр РазделителиСлов не задан, то разделителем слов считается любой из символов, 
// не относящихся к символам латиницы, кириллицы, цифры, подчеркивания.
//
// Параметры:
//  Значение        - Строка - исходная строка, которую необходимо разложить на слова.
//  РазделителиСлов - Строка - перечень символов-разделителей. Например, ".,;".
//
// Возвращаемое значение:
//  Массив - список слов.
//
// Пример:
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов("один-@#два2_!три") возвратит массив значений: "один",
//  "два2_", "три"; СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов("один-@#два2_!три", "#@!_") возвратит массив
//  значений: "один-", "два2", "три".
//
Функция РазложитьСтрокуВМассивСлов(Знач Значение, РазделителиСлов = Неопределено) Экспорт
	
	Слова = Новый Массив;
	
	РазмерТекста = СтрДлина(Значение);
	НачалоСлова = 1;
	Для Позиция = 1 По РазмерТекста Цикл
		КодСимвола = КодСимвола(Значение, Позиция);
		Если ЭтоРазделительСлов(КодСимвола, РазделителиСлов) Тогда
			Если Позиция <> НачалоСлова Тогда
				Слова.Добавить(Сред(Значение, НачалоСлова, Позиция - НачалоСлова));
			КонецЕсли;
			НачалоСлова = Позиция + 1;
		КонецЕсли;
	КонецЦикла;
	
	Если Позиция <> НачалоСлова Тогда
		Слова.Добавить(Сред(Значение, НачалоСлова, Позиция - НачалоСлова));
	КонецЕсли;
	
	Возврат Слова;
	
КонецФункции

// Определяет, является ли символ разделителем.
//
// Параметры:
//  КодСимвола      - Число  - код проверяемого символа;
//  РазделителиСлов - Строка - символы разделителей. Если параметр не указан, то 
//                             разделителем считаются все символы, не являющиеся цифрами, 
//                             латинскими и кириллическими буквами, а также знаком подчеркивания.
//
// Возвращаемое значение:
//  Булево - Истина, если символ с кодом КодСимвола является разделителем.
//
Функция ЭтоРазделительСлов(КодСимвола, РазделителиСлов = Неопределено) Экспорт
	
	Если РазделителиСлов <> Неопределено Тогда
		Возврат СтрНайти(РазделителиСлов, Символ(КодСимвола)) > 0;
	КонецЕсли;
		
	Диапазоны = Новый Массив;
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 48, 57)); 		// цифры
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 65, 90)); 		// латиница большие
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 97, 122)); 		// латиница маленькие
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 1040, 1103)); 	// кириллица
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 1025, 1025)); 	// символ "Ё"
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 1105, 1105)); 	// символ "ё"
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 95, 95)); 		// символ "_"
	
	Для Каждого Диапазон Из Диапазоны Цикл
		Если КодСимвола >= Диапазон.Мин И КодСимвола <= Диапазон.Макс Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

ЕстьИзменения = Ложь;