Перем ЕстьИзменения;
Перем кэшРазделителиСлов;

// Выравнивает код по установленным фрагментам
//
// Параметры:
//  ИсходныйКод  - ТабличныйДокумент - Код для выравнивания.
//
// Возвращаемое значение:
//   Булево   - Есть изменения
//
Функция ВыровнитьКод( ИсходныйКод ) Экспорт
	
	ЕстьИзменения = Ложь;
	
	ФорматироватьПереносы( ИсходныйКод );
	
	// Расстановка пробелов
	
	Для цНомерСтроки = 1 По ИсходныйКод.КоличествоСтрок() Цикл
		
		цТекСтрока = ИсходныйКод.ПолучитьСтроку( цНомерСтроки );
		
		строкаИзменена = Ложь;
		
		строкаИзменена = ПривестиЗапятыеКНорме( цТекСтрока );
		
		Для каждого цЗнак Из АрифметическиеЗнаки() Цикл
			
			строкаИзменена = ПривестиАрифметическиеЗнакиКНорме( цТекСтрока, цЗнак ) ИЛИ строкаИзменена;
			
		КонецЦикла;
		
		строкаИзменена = ПривестиЗнакиРавноКНорме( цТекСтрока )          ИЛИ строкаИзменена;
		строкаИзменена = ПривестиОткрывающиесяСкобкиКНорме( цТекСтрока ) ИЛИ строкаИзменена;
		строкаИзменена = ПривестиЗакрывающиесяСкобкиКНорме( цТекСтрока ) ИЛИ строкаИзменена;
		строкаИзменена = УдалитьПробелыСправа( цТекСтрока )              ИЛИ строкаИзменена;
		
		Если строкаИзменена Тогда
		
			ИсходныйКод.ЗаменитьСтроку( цНомерСтроки, цТекСтрока );
			ЕстьИзменения = Истина;
		
		КонецЕсли;
		
	КонецЦикла;
	
	// Выравнивание по фрагментам
	
	Для каждого цФрагмент Из ФрагментыВыравнивания() Цикл
		
		ВыровнитьКодПоФрагменту( ИсходныйКод, цФрагмент );
		
	КонецЦикла;
	
	Возврат ЕстьИзменения;
	
КонецФункции

Функция ФрагментыВыравнивания()
	
	фрагментыВыравнивания = Новый СписокЗначений;    // Используется список, чтобы сохранить порядок
	фрагментыВыравнивания.Добавить( "=",  "Право" ); // Право означает, что фрагмент будет находится справа от добавленных пробелов
	фрагментыВыравнивания.Добавить( ",",  "Лево" );  // см. пример в функции РазделителиСлов
	фрагментыВыравнивания.Добавить( "//", "Право" ); // Выравнивание комментариев, как в тут
	
	Возврат фрагментыВыравнивания;
	
КонецФункции

Функция АрифметическиеЗнаки()
	
	Возврат СтрРазделить( "<=,>=,+,-", "," );
	
КонецФункции


Функция СдвигПревышение()
	
	Возврат 12;
	
КонецФункции

Функция ДобавлятьПробелыВнутриСкобок()
	
	Возврат Истина;
	
КонецФункции

Функция ОграничениеДлиныСтроки()
	
	Возврат 120;
	
КонецФункции


Функция РазделителиБлоков()
	
	РазделителиБлоков = Новый Соответствие;
	РазделителиБлоков.Вставить( "ЕСЛИ", Истина );
	РазделителиБлоков.Вставить( "#ЕСЛИ",             Истина );
	РазделителиБлоков.Вставить( "ИНАЧЕЕСЛИ",         Истина );
	РазделителиБлоков.Вставить( "КОНЕЦЕСЛИ",         Истина );
	РазделителиБлоков.Вставить( "#КОНЕЦЕСЛИ",        Истина );
	РазделителиБлоков.Вставить( "ТОГДА",             Истина );
	РазделителиБлоков.Вставить( "И",    Истина );
	РазделителиБлоков.Вставить( "ИЛИ",  Истина );
	РазделителиБлоков.Вставить( "НЕ",   Истина );
	РазделителиБлоков.Вставить( "ИЗ",   Истина );
	РазделителиБлоков.Вставить( "КАЖДОГО",           Истина );
	РазделителиБлоков.Вставить( "ДЛЯ",  Истина );
	РазделителиБлоков.Вставить( "ЦИКЛ", Истина );
	РазделителиБлоков.Вставить( "ПОКА", Истина );
	РазделителиБлоков.Вставить( "ПРОЦЕДУРА",         Истина );
	РазделителиБлоков.Вставить( "ФУНКЦИЯ",           Истина );
	РазделителиБлоков.Вставить( "КОНЕЦПРОЦЕДУРЫ",    Истина );
	РазделителиБлоков.Вставить( "КОНЕЦФУНКЦИИ",      Истина );
	РазделителиБлоков.Вставить( "ЭКСПОРТ",           Истина );
	РазделителиБлоков.Вставить( "ПЕРЕМ",             Истина );
	РазделителиБлоков.Вставить( "ЗНАЧ", Истина );
	РазделителиБлоков.Вставить( "ПЕРЕЙТИ",           Истина );
	РазделителиБлоков.Вставить( "ВЫЗВАТЬИСКЛЮЧЕНИЕ", Истина );
	РазделителиБлоков.Вставить( "ПОПЫТКА",           Истина );
	РазделителиБлоков.Вставить( "ИСКЛЮЧЕНИЕ",        Истина );
	РазделителиБлоков.Вставить( "КОНЕЦПОПЫТКИ",      Истина );
	РазделителиБлоков.Вставить( "ВОЗВРАТ",           Истина );
	
	Возврат РазделителиБлоков;
	
КонецФункции

Процедура ВыровнитьКодПоФрагменту( ТекстовыйДокумент, Знач пФрагмент )
	
	фрагмент     = пФрагмент.Значение;
	выравнивание = пФрагмент.Представление;
	
	массивСтрок = Новый Массив;
	
	Для цНомерСтроки = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		
		цТекСтрока = ТекстовыйДокумент.ПолучитьСтроку( цНомерСтроки );
		
		индексФрагмента = ПозицияФрагмента( цТекСтрока, фрагмент );
		
		Если индексФрагмента > 0
			И ПодходитДляВыравнивания( цТекСтрока, индексФрагмента ) Тогда
			
			массивСтрок.Добавить( цНомерСтроки );
			
			СвернутьПробелы( цТекСтрока, фрагмент, выравнивание );
			ТекстовыйДокумент.ЗаменитьСтроку( цНомерСтроки, цТекСтрока );
			
		Иначе
			
			РазвернутьПробелы( ТекстовыйДокумент, массивСтрок, фрагмент, выравнивание );
			
		КонецЕсли;
		
	КонецЦикла;
	
	РазвернутьПробелы( ТекстовыйДокумент, массивСтрок, фрагмент, выравнивание );
	
КонецПроцедуры

Функция ПодходитДляВыравнивания( Знач пСтрока, пИндексФрагмента )
	
	Если Найти( СокрЛ( пСтрока ), "//" ) = 1 Тогда
	
		// Если строка полностью состоит из комментария, то не трогаем ее
		
		Возврат Ложь;
		
	КонецЕсли;
	
	индексКомментария = ПозицияФрагмента( пСтрока, "//" );
	
	Если пИндексФрагмента > индексКомментария
		И Не индексКомментария = 0 Тогда
		
		// Нужный фрагмент закомментирован. Так же стоит учитывать, что выравнивание может происходить как раз комментариев,
		// поэтому сравнение строгое.
		
		Возврат Ложь;
		
	КонецЕсли;
	
	массивСлов = РазложитьСтрокуВМассивСлов( СокрЛП( пСтрока ) );
	
	Если массивСлов.Количество() = 0 Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	Если Не РазделителиБлоков()[ ВРег( массивСлов[0] ) ] = Неопределено Тогда
	
		// Первое слово не является словом, разбивающем блок
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция ПозицияФрагмента( Знач пСтрока, Знач пФрагмент )
	
	позицияФрагмента = СтрНайти( пСтрока, пФрагмент );
	
	Если позицияФрагмента = 0 Тогда
	
		Возврат 0;
		
	КонецЕсли;
	
	Если Не пФрагмент = "//" Тогда
		
		ПозицияКомментария = ПозицияФрагмента( пСтрока, "//" );
		
		Если ПозицияКомментария > 0
			И ПозицияКомментария < позицияФрагмента Тогда
			
			Возврат 0;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ПозицияКавычек = СтрНайти( пСтрока, """" );
	// Проверяем есть ли вначале строки символ "|".
	ПервыйСимвол = Сред( СокрЛП( пСтрока ), 1, 1 );
	
	// Нет кавычек, оставляем весь комментарий.
	// Кавычки после комментария, оставляем весь комментарий.
	Если ( ПозицияКавычек = 0 ИЛИ ПозицияКавычек > позицияФрагмента )
		И ПервыйСимвол <> "|" Тогда
		
		Возврат позицияФрагмента;
		
	ИначеЕсли ПервыйСимвол = "|"
	
		И ПозицияКавычек = 0 Тогда
		
		// Все в строке
		
		Возврат 0;
		
	ИначеЕсли ПервыйСимвол = "|"
	
		И ПозицияКавычек > 0 Тогда
		
		строкаПослеКавычек = Сред( пСтрока, ПозицияКавычек + 1 );
		
		позицияФрагмента = ПозицияФрагмента( строкаПослеКавычек, пФрагмент );
		
		Если позицияФрагмента = 0 Тогда
		
			Возврат 0;
			
		Иначе
		
			Возврат ПозицияКавычек + позицияФрагмента;
			
		КонецЕсли;
		
	Иначе
		
		строкаПослеКавычек = "|" + Сред( пСтрока, ПозицияКавычек + 1 );
		
		позицияФрагмента = ПозицияФрагмента( строкаПослеКавычек, пФрагмент );
		
		Если позицияФрагмента = 0 Тогда
		
			Возврат 0;
			
		Иначе
		
			Возврат ПозицияКавычек + позицияФрагмента - 1;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

Функция ПривестиЗапятыеКНорме( пСтрока )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат  = "";
	остатокСтроки = пСтрока;
	
	позицияЗапятой = ПозицияФрагмента( остатокСтроки, "," );
	
	Если позицияЗапятой = 0 Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	Пока Не позицияЗапятой = 0 Цикл
		
		строкаПослеЗапятой = Сред( остатокСтроки, позицияЗапятой + 1 );
		строкаДоЗапятой    = Лев( остатокСтроки,  позицияЗапятой - 1 );
		
		стрРезультат = стрРезультат + СокрП( строкаДоЗапятой ) + ", ";
		
		остатокСтроки  = СокрЛ( строкаПослеЗапятой );
		позицияЗапятой = ПозицияФрагмента( остатокСтроки, "," );
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + СокрЛ( остатокСтроки );
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ПривестиЗнакиРавноКНорме( пСтрока )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат  = "";
	остатокСтроки = пСтрока;
	
	позицияРавно = ПозицияФрагмента( остатокСтроки, "=" );
	
	Если позицияРавно = 0 Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	Пока Не позицияРавно = 0 Цикл
		
		строкаПослеРавно = Сред( остатокСтроки, позицияРавно + 1 );
		строкаДоРавно    = Лев( остатокСтроки,  позицияРавно - 1 );
		
		Если СтрЗаканчиваетсяНа( строкаДоРавно, ">" )
			ИЛИ СтрЗаканчиваетсяНа( строкаДоРавно, "<" ) Тогда
			
			стрРезультат = стрРезультат + СокрП( строкаДоРавно ) + "= ";
			
		Иначе
			
			стрРезультат = стрРезультат + СокрП( строкаДоРавно ) + " = ";
			
		КонецЕсли;
		
		остатокСтроки = СокрЛ( строкаПослеРавно );
		позицияРавно  = ПозицияФрагмента( остатокСтроки, "=" );
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + СокрЛ( остатокСтроки );
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ПривестиАрифметическиеЗнакиКНорме( пСтрока, пФрагмент )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат   = "";
	длинаФрагмента = СтрДлина( пФрагмент );
	остатокСтроки  = пСтрока;
	
	позицияФрагмента = ПозицияФрагмента( остатокСтроки, пФрагмент );
	
	Если позицияФрагмента = 0 Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	Пока Не позицияФрагмента = 0 Цикл
		
		строкаПослеФрагмента = Сред( остатокСтроки, позицияФрагмента + длинаФрагмента );
		строкаДоФрагмента    = Лев( остатокСтроки,  позицияФрагмента - 1 );
		
		стрРезультат = стрРезультат + СокрП( строкаДоФрагмента ) + " " + пФрагмент + " ";
		
		остатокСтроки    = СокрЛ( строкаПослеФрагмента );
		позицияФрагмента = ПозицияФрагмента( остатокСтроки, пФрагмент );
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + СокрЛ( остатокСтроки );
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции


Функция ПривестиОткрывающиесяСкобкиКНорме( пСтрока )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат  = "";
	остатокСтроки = пСтрока;
	
	позицияСкобки = ПозицияФрагмента( остатокСтроки, "(" );
	
	Если позицияСкобки = 0 Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ДобавлятьПробелыВнутриСкобок() Тогда
	
		пробел = " ";
	
	Иначе
	
		пробел = "";
	
	КонецЕсли;
	
	Пока Не позицияСкобки = 0 Цикл
		
		строкаПослеСкобки = Сред( остатокСтроки, позицияСкобки + 1 );
		строкаДоСкобки    = Лев( остатокСтроки,  позицияСкобки - 1 );
		
		стрРезультат = стрРезультат + строкаДоСкобки + "(";
		
		остатокСтроки = СокрЛ( строкаПослеСкобки );
		
		Если Не СтрНачинаетсяС( остатокСтроки, ")" ) Тогда
		
			стрРезультат = стрРезультат + пробел;
		
		КонецЕсли;
		
		позицияСкобки = ПозицияФрагмента( остатокСтроки, "(" );
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + остатокСтроки;
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ПривестиЗакрывающиесяСкобкиКНорме( пСтрока )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	стрРезультат  = "";
	остатокСтроки = пСтрока;
	
	позицияСкобки = ПозицияФрагмента( остатокСтроки, ")" );
	
	Если позицияСкобки = 0 Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ДобавлятьПробелыВнутриСкобок() Тогда
	
		пробел = " ";
	
	Иначе
	
		пробел = "";
	
	КонецЕсли;
	
	Пока Не позицияСкобки = 0 Цикл
		
		строкаПослеСкобки = Сред( остатокСтроки,       позицияСкобки + 1 );
		строкаДоСкобки    = СокрП( Лев( остатокСтроки, позицияСкобки - 1 ) );
		
		Если Не СтрЗаканчиваетсяНа( строкаДоСкобки, "(" ) Тогда
		
			строкаДоСкобки = строкаДоСкобки + пробел;
		
		КонецЕсли;
		
		стрРезультат = стрРезультат + строкаДоСкобки + ")";
		
		остатокСтроки = строкаПослеСкобки;
		
		позицияСкобки = ПозицияФрагмента( остатокСтроки, ")" );
		
	КонецЦикла;
	
	стрРезультат = стрРезультат + остатокСтроки;
	
	Если стрРезультат = пСтрока Тогда
		
		Возврат Ложь;
		
	Иначе
		
		пСтрока = стрРезультат;
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции


Функция УдалитьПробелыСправа( пСтрока )
	
	Если Не ЗначениеЗаполнено( пСтрока ) Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	Если пСтрока = СокрП( пСтрока ) Тогда
	
		Возврат Ложь;
		
	Иначе
	
		пСтрока = СокрП( пСтрока );
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции // УдалитьПробелыСправа()


Процедура СвернутьПробелы( пСтрока, Знач пФрагмент, Знач пВыравнивание )
	
	ЕстьИзменения = Истина;
	
	индексФрагмента = ПозицияФрагмента( пСтрока, пФрагмент );
	
	Если пВыравнивание = "Право" Тогда
		
		пСтрока = СокрП( Лев( пСтрока, индексФрагмента - 1 ) ) + " " + Сред( пСтрока, индексФрагмента );
		
	ИначеЕсли пВыравнивание = "Лево" Тогда
		
		размерФрагмента = СтрДлина( пФрагмент );
		пСтрока         = Лев( пСтрока, индексФрагмента + размерФрагмента - 1 ) + " " + СокрЛ( Сред( пСтрока, индексФрагмента + размерФрагмента ) );
		
	КонецЕсли;
	
КонецПроцедуры

Процедура РазвернутьПробелы( пТекстДок, пМассивСтрок, Знач пФрагмент, Знач пВыравнивание )
	
	Если пМассивСтрок.Количество() = 0 Тогда
	
		Возврат;
		
	КонецЕсли;
	
	ЕстьИзменения = Истина;
	
	максПозиция = 0;
	
	Для каждого цНомерСтроки Из пМассивСтрок Цикл
		
		текСтрока = пТекстДок.ПолучитьСтроку( цНомерСтроки );
		
		максПозиция = Макс( ПозицияФрагмента( текСтрока, пФрагмент ), максПозиция );
		
	КонецЦикла;
	
	размерФрагмента = СтрДлина( пФрагмент );
	
	массивКороткихСтрок = Новый Массив();
	сдвигПревышение     = СдвигПревышение();
	
	Для каждого цНомерСтроки Из пМассивСтрок Цикл
		
		текСтрока = пТекстДок.ПолучитьСтроку( цНомерСтроки );
		
		индексФрагмента = ПозицияФрагмента( текСтрока, пФрагмент );
		
		Если максПозиция - индексФрагмента > сдвигПревышение Тогда
			
			массивКороткихСтрок.Добавить( цНомерСтроки );
			Продолжить;
			
		КонецЕсли;
		
		СтрокаПробелов = "";
		
		Для СчПробелов = 1 По максПозиция - индексФрагмента Цикл
		
			СтрокаПробелов = СтрокаПробелов + " ";
		
		КонецЦикла;
		
		Если пВыравнивание = "Право" Тогда
			
			НоваяСтрока = Лев( текСтрока, индексФрагмента - 1 ) + СтрокаПробелов + Сред( текСтрока, индексФрагмента );
			
		ИначеЕсли пВыравнивание = "Лево" Тогда
			
			НоваяСтрока = Лев( текСтрока, индексФрагмента + размерФрагмента - 1 ) + СтрокаПробелов + Сред( текСтрока, индексФрагмента + размерФрагмента );
			
		КонецЕсли;
		
		пТекстДок.ЗаменитьСтроку( цНомерСтроки, СокрП( НоваяСтрока ) );
		
	КонецЦикла;
	
	РазвернутьПробелы( пТекстДок, массивКороткихСтрок, пФрагмент, пВыравнивание );
	
	пМассивСтрок = Новый Массив;
	
КонецПроцедуры



// Разбивает строку на несколько строк, используя заданный набор разделителей.
// Если параметр РазделителиСлов не задан, то разделителем слов считается любой из символов,
// не относящихся к символам латиницы, кириллицы, цифры, подчеркивания.
//
// Параметры:
//  Значение        - Строка - исходная строка, которую необходимо разложить на слова.
//  РазделителиСлов - Строка - перечень символов-разделителей. Например, ".,;".
//
// Возвращаемое значение:
//  Массив - список слов.
//
// Пример:
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов("один-@#два2_!три") возвратит массив значений: "один",
//  "два2_", "три"; СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов("один-@#два2_!три", "#@!_") возвратит массив
//  значений: "один-", "два2", "три".
//
Функция РазложитьСтрокуВМассивСлов( Знач Значение ) Экспорт
	
	Слова = Новый Массив;
	
	РазмерТекста = СтрДлина( Значение );
	НачалоСлова  = 1;
	
	Для Позиция = 1 По РазмерТекста Цикл
	
		КодСимвола = КодСимвола( Значение, Позиция );
		Если ЭтоРазделительСлов( КодСимвола ) Тогда
		
			Если Позиция <> НачалоСлова Тогда
			
				Слова.Добавить( Сред( Значение, НачалоСлова, Позиция - НачалоСлова ) );
			
			КонецЕсли;
			
			НачалоСлова = Позиция + 1;
		
		КонецЕсли;
		
	КонецЦикла;
	
	Если Позиция <> НачалоСлова Тогда
	
		Слова.Добавить( Сред( Значение, НачалоСлова, Позиция - НачалоСлова ) );
	
	КонецЕсли;
	
	Возврат Слова;
	
КонецФункции

// Определяет, является ли символ разделителем.
//
// Параметры:
//  КодСимвола      - Число  - код проверяемого символа;
//  РазделителиСлов - Строка - символы разделителей. Если параметр не указан, то
//                             разделителем считаются все символы, не являющиеся цифрами,
//                             латинскими и кириллическими буквами, а также знаком подчеркивания.
//
// Возвращаемое значение:
//  Булево - Истина, если символ с кодом КодСимвола является разделителем.
//
Функция ЭтоРазделительСлов( КодСимвола ) Экспорт
	
	значениеКеша = кэшРазделителиСлов[ КодСимвола ];
	
	Если Не значениеКеша = Неопределено Тогда
	
		Возврат значениеКеша;
		
	КонецЕсли;
	
	Диапазоны = Новый Массив;
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 48, 57 ) );     // цифры
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 65, 90 ) );     // латиница большие
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 97, 122 ) );    // латиница маленькие
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 1040, 1103 ) ); // кириллица
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 1025, 1025 ) ); // символ "Ё"
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 1105, 1105 ) ); // символ "ё"
	Диапазоны.Добавить( Новый Структура( "Мин,Макс", 95, 95 ) );     // символ "_"
	
	Для Каждого Диапазон Из Диапазоны Цикл
	
		Если КодСимвола >= Диапазон.Мин И КодСимвола <= Диапазон.Макс Тогда
		
			кэшРазделителиСлов.Вставить( КодСимвола, Ложь );
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	кэшРазделителиСлов.Вставить( КодСимвола, Истина );
	
	Возврат Истина;
	
КонецФункции


Процедура ФорматироватьПереносы( пИсходныйКод )
	
	текстИзменен = Ложь;
	
	новыйКод = Новый ТекстовыйДокумент;
	
	добавитьПустуюСтроку  = 0;
	последняяСтрокаПустая = Ложь;
	отступыПустойСтроки   = "";
	
	Для цНомерСтроки = 1 По пИсходныйКод.КоличествоСтрок() Цикл
		
		цТекСтрока     = пИсходныйКод.ПолучитьСтроку( цНомерСтроки );
		строкаИзменена = Ложь;
		
		Если последняяСтрокаПустая Тогда
		
			добавитьПустуюСтроку = 0;
		
		КонецЕсли;
		
		Если ЗначениеЗаполнено( цТекСтрока )
			И ( добавитьПустуюСтроку >= 2
			ИЛИ ( добавитьПустуюСтроку = 1
			И Не ЭтоКонецАбзаца( цТекСтрока ) = 1 ) ) Тогда
			
			новыйКод.ДобавитьСтроку( отступыПустойСтроки );
			текстИзменен          = Истина;
			добавитьПустуюСтроку  = 0;
			последняяСтрокаПустая = Истина;
			
		КонецЕсли;
		
		добавитьПустуюСтроку = ЭтоКонецАбзаца( цТекСтрока );
		Если добавитьПустуюСтроку > 0 Тогда
		
			отступыПустойСтроки = ПолучитьОтступы( цТекСтрока );
		
		КонецЕсли;
		
		Если добавитьПустуюСтроку = 3
			И Не последняяСтрокаПустая Тогда
			
			новыйКод.ДобавитьСтроку( отступыПустойСтроки );
			текстИзменен = Истина;
		
		КонецЕсли;
		
		Если Не строкаИзменена Тогда
		
			новыйКод.ДобавитьСтроку( цТекСтрока );
			последняяСтрокаПустая = ПустаяСтрока( цТекСтрока );
		
		Иначе
		
			текстИзменен = Истина;
			новыйКод.ДобавитьСтроку( цТекСтрока );
			последняяСтрокаПустая = ПустаяСтрока( цТекСтрока );
		
		КонецЕсли;
		
	КонецЦикла;
	
	Если текстИзменен Тогда
	
		ЕстьИзменения = Истина;
		пИсходныйКод  = новыйКод;
	
	КонецЕсли;
	
КонецПроцедуры

// 0 - это не конец абзаца
// 1 - это необязательный конец абзаца
// 2 - это обязательный конец абзаца.
Функция ЭтоКонецАбзаца( Знач пСтрока )
	
	СТРОКА = ВРег( пСтрока );
	
	Для каждого цЭлемент Из ПоследниеСловаВАбзаце() Цикл
		
		Если ПозицияФрагмента( СТРОКА, цЭлемент.Ключ ) > 0 Тогда
		
			Возврат цЭлемент.Значение;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат 0;
	
КонецФункции

Функция ПолучитьОтступы( Знач пСтрока )
	
	количествоОтступов = СтрДлина( пСтрока );
	
	Для ц = 1 По СтрДлина( пСтрока ) Цикл
		
		Если Не ПустаяСтрока( Сред( пСтрока, ц, 1 ) ) Тогда
		
			количествоОтступов = ц - 1;
			Прервать;
		
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Лев( пСтрока, количествоОтступов );
	
КонецФункции



// Слова, после которых должна быть пустая строка
Функция ПоследниеСловаВАбзаце()
	
	Слова = Новый Соответствие;
	Слова.Вставить( "КОНЕЦЕСЛИ",      3 );
	Слова.Вставить( "КОНЕЦЦИКЛА",     3 );
	Слова.Вставить( "ЦИКЛ",           3 );
	Слова.Вставить( "ТОГДА",          2 );
	Слова.Вставить( "ИНАЧЕ",          3 );
	Слова.Вставить( "#ИНАЧЕ",         3 );
	Слова.Вставить( "#КОНЕЦЕСЛИ",     3 );
	Слова.Вставить( "#КОНЕЦОБЛАСТИ",  3 );
	Слова.Вставить( "ПРОЦЕДУРА",      2 );
	Слова.Вставить( "ФУНКЦИЯ",        2 );
	Слова.Вставить( "КОНЕЦПРОЦЕДУРЫ", 3 );
	Слова.Вставить( "КОНЕЦФУНКЦИИ",   3 );
	Слова.Вставить( "ЭКСПОРТ",        2 );
	Слова.Вставить( "КОНЕЦПОПЫТКИ",   2 );
	Слова.Вставить( "ВОЗВРАТ",        3 );
	
	Возврат Слова;
	
КонецФункции

ЕстьИзменения      = Ложь;
кэшРазделителиСлов = Новый Соответствие;